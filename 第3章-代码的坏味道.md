## 代码的坏味道

+ 决定何时重构及何时停止和知道重构机制如何运转一样重要。
+ 我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，没有任何量度规矩比得上见识广博者的直觉

+ 我们只会告诉你一些迹象，它会指出“这里有一个可以用重构解决的问题”
+ 你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长

### 3.1 神秘命名(Mysterious Name)

+ 我们会深思熟虑如何给函数、模块、变量和类命名，使它们能清晰地表明自己的功能和用法
+ 然而， 命名是编程中最难的两件事之一
+ 改名可能是最常用的重构手法，包括改变函数声明（124）（用于给函数改名）、变量改名（137）、字段改名（244）等
+ 改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。
+ 为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。

### 3.2 重复代码(Duplicated Code)

+ 如果你在多处看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好
+ 最单纯的重复代码就是“同一个类的两个函数含有部分相同的结构”

### 3.3 过长的函数(Long Function)

+ 据我们的经验，活得最长、最好的程序，其中的函数都比较短
+ 小函数的好处:
  1. 更好的阐释力
  2. 更易于公用
  3. 更多的选择

+ 让小函数易于理解的关键还是在于良好的命名

+ 我们遵循这样一条原则：每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中
+ 如果函数内有大量的参数和临时变量, 你可以经常运用以查询取代临时变量（178）来消除这些临时元素
+ 引入参数对象（140）和保持对象完整（319）则可以将过长的参数列表变得更简洁一些。
+ 就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中去。
+ 条件表达式和循环常常也是提炼的信号
  - 你可以使用分解条件表达式（260）处理条件表达式。
  - 对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用
  - 如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。(即为创建基类，根据不同的case返回不同的子类)

+ 至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中
  - 如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事
  - 如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务。

### 3.4 过长的参数列表(Long Parameter List)

+ 如果使用全局数据, 全局数据很快就会变成邪恶的东西
+ 如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数
+ 如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构
+ 如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象
+ 如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）
+ 使用类可以有效地缩短参数列表
  - 如果多个函数有同样的几个参数，引入一个类就尤为有意义。
  - 你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。

### 3.5 全局数据(Global Data)

+ 全局数据的问题在于，从代码库的任何一个角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改
+ 全局数据最显而易见的形式就是全局变量，但类变量和单例（singleton）也有这样的问题。
  1. 首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招
  2. 你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问
  3. 最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，从而尽量控制其作用域。
+ 可以被修改的全局数据尤其可憎。如果一个全局变量不可修改，那么就把它声明为常量


### 3.6 可变数据(Mutable Data)

+ 对数据的修改经常导致出乎意料的结果和难以发现的 bug
  - 例如，别的使用者修改了这份数据，造成其他使用者，使用数据时与预期不符
+ 因此，有一个软件开发流派——函数式编程——完全建立在“数据永不改变”的概念基础上：如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变
+ 如果一个变量在其内部结构中包含了数据，通常最好不要直接修改其中的数据，而是用将引用对象改为值对象（252）令其直接替换整个数据结构
+ 设计 API 时，可以使用将查询函数和修改函数分离（306）确保调用者不会调到有副作用的代码

### 3.7 发散式变化（Divergent Change）

+ 我们希望软件能够更容易被修改

+ 一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改
+ 如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了

### 3.8  霰弹式修改（Shotgun Surgery）

+ 如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是霰弹式修改
+ 如果需要修改的代码散布四处，你不但很难找到它们，也很容易错过某个重要的修改。
+ 你应该使用搬移函数（198）和搬移字段（207）把所有需要修改的代码放进同一个模块里
+ 面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数（115）或是内联类（186）——把本不该分散的逻辑拽回一处

###  3.9 依恋情结（Feature Envy）

+ 所谓模块化，就是力求将代码分出区域，最大化区域内部的交互、最小化跨区域的交互。